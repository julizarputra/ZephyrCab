{
    "docs": [
        {
            "location": "/", 
            "text": "Before you read the full docs, it is suggested that you read README.md, provided \non GitHub\n. This quickstart guide is intended for relatively experienced computer users, so follow the more detailed user guide if you don't know what you're doing.\n\n\n\n\n\n\nQuickstart Guide\n\n\n\n\nPrerequisites\n\n\n\n\n\n\nA DCC layout connected to JMRI\n\n\n\n\n\n\nA web server (you can use the one built into JMRI)\n\n\n\n\n\n\n\n\nInstallation\n\n\nThis installation guide is for technically-minded developer/nerd people. If you need a simplified guide, try \nthis one.\n\n\nYou can download a release from GitHub. Once you have the release extracted from the ZIP, simply drag all the files into a directory on any web server. When you go to the web server, you should be left at a \"Connection Settings\" page that looks like this.\n\n\n\n\nBefore you proceed any further, you need to set up your \nbundles.json\n file. Unfortunately, there is no automated tool to do this as of now. You may see the comments in the code for explanation of how to set it up. Feel free to join the Gitter chat below if you want help!\n\n\n\n\nOnce you have your \nbundles.json\n set up, you should be able to use the program normally. Connect to your JMRI PC (if you don't know the IP, you will need to find that) using the \"Connection\" tab, and everything should work. If you run into problems, post an issue on \nthe project's GitHub page\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#quickstart-guide", 
            "text": "Prerequisites    A DCC layout connected to JMRI    A web server (you can use the one built into JMRI)     Installation  This installation guide is for technically-minded developer/nerd people. If you need a simplified guide, try  this one.  You can download a release from GitHub. Once you have the release extracted from the ZIP, simply drag all the files into a directory on any web server. When you go to the web server, you should be left at a \"Connection Settings\" page that looks like this.   Before you proceed any further, you need to set up your  bundles.json  file. Unfortunately, there is no automated tool to do this as of now. You may see the comments in the code for explanation of how to set it up. Feel free to join the Gitter chat below if you want help!   Once you have your  bundles.json  set up, you should be able to use the program normally. Connect to your JMRI PC (if you don't know the IP, you will need to find that) using the \"Connection\" tab, and everything should work. If you run into problems, post an issue on  the project's GitHub page .", 
            "title": "Quickstart Guide"
        }, 
        {
            "location": "/userguide/installation-guide/", 
            "text": "Server-Side Installation\n\n\n\n\n\n\n\n\nlocoThrottle.js runs in a browser. This means to use it, you'll need a web server. This server can be anywhere, and does not necessarily need to be on the same network as your JMRI PC since all code is client-side JavaScript.\n\n\n\n\nAdditionally, since the entire app is static, you can host it on anything you like, including services such as Amazon S3.\n\n\n\n\n\n\n\n\nIf you are not an experienced user, we recommend you use the web server already built into JMRI.\n You can read more on this at \nthe JMRI docs.\n\n\n\n\n\n\n\n\nUsing JMRI's Jetty server\n\n\nThis is the recommended way to install for new users.\n\n\n\n\n\n\nMake sure JMRI's Web Server is functional.\n \n\n\n\n\n\n\nThe default port is 12080, so from your JMRI PC you should be able to visit \nhttp://localhost:12080\n and see the web interface.\n\n\n\n\n\n\nMake sure that the web server is set to run on JMRI startup. \nRead more about JMRI Web Access here.\n\n\n\n\n\n\n\n\n\n\nExtract locoThrottle.js into the \n/web/locoThrottleJS\n directory inside your JMRI install folder.\n\n\n\n\n\n\nThis is what ultimately determines the URL you must use to access locoThrottle.js, so make sure you do this right.\n\n\n\n\n\n\nYou want to extract the contents of the release (from the ZIP) into \n/web/locoThrottleJS\n. This should put a whole bunch of files (including \nindex.html\n) in that folder.\n\n\n\n\n\n\n\n\n\n\nVisit the page in your browser\n\n\n\n\n\n\nIf you did step 2 correctly, you should be able to access locoThrottle.js by adding \n/web/locoThrottleJS\n onto your normal web access folder path.\n\n\n\n\n\n\nFor example, if you are viewing this on your JMRI machine, your web access path is \nhttp://localhost:12080\n. Your locoThrottle.js path would be \nhttp://localhost:12080/web/locoThrottleJS\n.\n\n\n\n\n\n\nIf you plan on using locoThrottle.js from another PC, or a mobile device, you should set a static IP on your JMRI PC.\n\n\n\n\n\n\nIf it worked, you should be left at the \"Connection\" tab when you open the page in a browser. If you get \"Connection Refused\" or a similar error, check to be sure that your firewall is set to allow JMRI through. This has not historically been a problem in Linux, but in Windows it could be an issue.\n\n\n\n\n\n\n\n\n\n\n\n\nUsing your own web server\n\n\nlocoThrottle.js is built as an entirely static HTML/CSS/JS app. This means you can install it on any web server, regardless of whether or not it can handle things like PHP, or Python. All the code runs client-side.\n\n\nTo install it on your own server, simply drag and drop the extracted release files into a directory of your choice. It should not matter what directory you put them in, or what network the server is on. As long as the client device is connected to the same network as your JMRI PC, you should have access to JMRI.\n\n\nWe do not provide an official guide for setting it up on your own web server because it's so simple. If you don't know what you're doing, or you want an easier way, use the \nUsing JMRI's Jetty server\n guide above.\n\n\n\n\nSo what now?\n\n\nNext, you'll need to set up your \nbundles\n object. This is what links your locomotive roster entries to all the data we need about them. You can follow \nthis tutorial to find out how to do it.", 
            "title": "Installation Guide"
        }, 
        {
            "location": "/userguide/installation-guide/#server-side-installation", 
            "text": "locoThrottle.js runs in a browser. This means to use it, you'll need a web server. This server can be anywhere, and does not necessarily need to be on the same network as your JMRI PC since all code is client-side JavaScript.   Additionally, since the entire app is static, you can host it on anything you like, including services such as Amazon S3.     If you are not an experienced user, we recommend you use the web server already built into JMRI.  You can read more on this at  the JMRI docs.     Using JMRI's Jetty server  This is the recommended way to install for new users.    Make sure JMRI's Web Server is functional.      The default port is 12080, so from your JMRI PC you should be able to visit  http://localhost:12080  and see the web interface.    Make sure that the web server is set to run on JMRI startup.  Read more about JMRI Web Access here.      Extract locoThrottle.js into the  /web/locoThrottleJS  directory inside your JMRI install folder.    This is what ultimately determines the URL you must use to access locoThrottle.js, so make sure you do this right.    You want to extract the contents of the release (from the ZIP) into  /web/locoThrottleJS . This should put a whole bunch of files (including  index.html ) in that folder.      Visit the page in your browser    If you did step 2 correctly, you should be able to access locoThrottle.js by adding  /web/locoThrottleJS  onto your normal web access folder path.    For example, if you are viewing this on your JMRI machine, your web access path is  http://localhost:12080 . Your locoThrottle.js path would be  http://localhost:12080/web/locoThrottleJS .    If you plan on using locoThrottle.js from another PC, or a mobile device, you should set a static IP on your JMRI PC.    If it worked, you should be left at the \"Connection\" tab when you open the page in a browser. If you get \"Connection Refused\" or a similar error, check to be sure that your firewall is set to allow JMRI through. This has not historically been a problem in Linux, but in Windows it could be an issue.       Using your own web server  locoThrottle.js is built as an entirely static HTML/CSS/JS app. This means you can install it on any web server, regardless of whether or not it can handle things like PHP, or Python. All the code runs client-side.  To install it on your own server, simply drag and drop the extracted release files into a directory of your choice. It should not matter what directory you put them in, or what network the server is on. As long as the client device is connected to the same network as your JMRI PC, you should have access to JMRI.  We do not provide an official guide for setting it up on your own web server because it's so simple. If you don't know what you're doing, or you want an easier way, use the  Using JMRI's Jetty server  guide above.   So what now?  Next, you'll need to set up your  bundles  object. This is what links your locomotive roster entries to all the data we need about them. You can follow  this tutorial to find out how to do it.", 
            "title": "Server-Side Installation"
        }, 
        {
            "location": "/userguide/general-configuration/", 
            "text": "General Configuration\n\n\nWhile you still have to configure settings separately for things like locomotives, decoders, and other things, there is a central place to set up general program settings. Inside your installation directory, \n/cfg/settings.json\n contains a number of useful settings/options for general use.\n\n\n\n\nYou will not need any programming knowledge to edit this file. If you can read and follow directions, you can set this up.\n\n\n\n\nOptions Available:\n\n\n\n\n\n\nWebSockets Auto-Connect\n - This feature allows you to specify an IP/Port in \nsettings.json\n and have all your clients auto-connect to that. They will get to skip the \"Connection\" tab completely, and will be dropped directly in the \"Train Settings\" tab. Since locoThrottle.js performs all the normal connection functions, this means your roster data, layout information, and other things will already be downloaded, parsed, and ready to go. Incredibly handy feature!\n\n\n\n\n\n\nDisable Push Notifications\n - This feature disables the push notifications feature we created. This feature is for alerting users when major program changes are made, and just as a communication tool for our users who don't regularly visit GitHub. Setting this configuration option to \ntrue\n will not disable the \"HUB\" feature completely, it will only disable the push notifications feature.\n\n\n\n\n\n\nEnable Debug Toasts\n - This feature enables a \"debug mode\" of sorts. 90% of users should leave this set to \nfalse\n. When you enable this, you will recieve more detailed information from many functions about what's going on. Developers can make use of this feature with the \ndebugToast()\n function, which behaves exactly the same as the \nMaterialize.toast()\n function, except it appends \"Debug: \" to the beginning of the toast, and it only works when the \ncfg.debugToasts\n is \ntrue\n.\n\n\n\n\n\n\nLog all WebSockets messages\n - This will log every piece of WebSockets data to the console, including heartbeats, as a string. Sent commands will be prefaced with \nSENT :\n, and recieved data with \nRECIEVED :\n. This is for developers only, and will make your console a bit messy. If you'd rather log the objects directly as opposed to stringified, you can tweak your \nwebsockets.js\n pretty easily if you know basic JavaScript. \nGet in touch with me\n if you need help with this.\n\n\n\n\n\n\n\n\nExample \nsettings.json\n\n\nThe following is an example of settings.json with every option we currently support. See the comments in the code (marked by \n/*\n and \n*/\n) for detailed information on usage.\n\n\ncfg = new Object(); //DO NOT REMOVE THIS LINE!\n\n/*\nThis file is used to store settings server-side. This is capable of storing an IP address to connect to automatically, as well as other things.\n*/\n\n/*\nThese two settings are for the WebSockets Auto-Connect feature mentioned above.\n\ncfg.ip - Set to a string (either an IP or hostname)\ncfg.port - Set to a port number (not a string)\n\nIf you do not wish to use the autoconnect feature, simply comment these out by adding // at the begining of each line. This will revert the program back to its original ask-for-connection-details behavior.\n\nExample disabled autoconnect:\n\n//cfg.ip = \n10.10.39.85\n;\n//cfg.port = 12080;\n\n*/\ncfg.ip = \n10.10.39.85\n;\ncfg.port = 12080;\n\n/*\nThis setting, as explained above, disables the \nHUB\n push notifications feature when set to true.\n*/\ncfg.disablePushNotifications = false; //this leaves push notifications on\n\ncfg.debugToasts = true;\n\ncfg.logallmessages = false; //This will log EVERY WebSockets message that is sent or recieved to the console as a string. This is meant for copying/pasting into GitHub issues and such. It prefaces messages we send with \nSENT : \n and messages from JMRI with \nRECIEVED :", 
            "title": "General Configuration"
        }, 
        {
            "location": "/userguide/general-configuration/#general-configuration", 
            "text": "While you still have to configure settings separately for things like locomotives, decoders, and other things, there is a central place to set up general program settings. Inside your installation directory,  /cfg/settings.json  contains a number of useful settings/options for general use.   You will not need any programming knowledge to edit this file. If you can read and follow directions, you can set this up.", 
            "title": "General Configuration"
        }, 
        {
            "location": "/userguide/general-configuration/#options-available", 
            "text": "WebSockets Auto-Connect  - This feature allows you to specify an IP/Port in  settings.json  and have all your clients auto-connect to that. They will get to skip the \"Connection\" tab completely, and will be dropped directly in the \"Train Settings\" tab. Since locoThrottle.js performs all the normal connection functions, this means your roster data, layout information, and other things will already be downloaded, parsed, and ready to go. Incredibly handy feature!    Disable Push Notifications  - This feature disables the push notifications feature we created. This feature is for alerting users when major program changes are made, and just as a communication tool for our users who don't regularly visit GitHub. Setting this configuration option to  true  will not disable the \"HUB\" feature completely, it will only disable the push notifications feature.    Enable Debug Toasts  - This feature enables a \"debug mode\" of sorts. 90% of users should leave this set to  false . When you enable this, you will recieve more detailed information from many functions about what's going on. Developers can make use of this feature with the  debugToast()  function, which behaves exactly the same as the  Materialize.toast()  function, except it appends \"Debug: \" to the beginning of the toast, and it only works when the  cfg.debugToasts  is  true .    Log all WebSockets messages  - This will log every piece of WebSockets data to the console, including heartbeats, as a string. Sent commands will be prefaced with  SENT : , and recieved data with  RECIEVED : . This is for developers only, and will make your console a bit messy. If you'd rather log the objects directly as opposed to stringified, you can tweak your  websockets.js  pretty easily if you know basic JavaScript.  Get in touch with me  if you need help with this.", 
            "title": "Options Available:"
        }, 
        {
            "location": "/userguide/general-configuration/#example-settingsjson", 
            "text": "The following is an example of settings.json with every option we currently support. See the comments in the code (marked by  /*  and  */ ) for detailed information on usage.  cfg = new Object(); //DO NOT REMOVE THIS LINE!\n\n/*\nThis file is used to store settings server-side. This is capable of storing an IP address to connect to automatically, as well as other things.\n*/\n\n/*\nThese two settings are for the WebSockets Auto-Connect feature mentioned above.\n\ncfg.ip - Set to a string (either an IP or hostname)\ncfg.port - Set to a port number (not a string)\n\nIf you do not wish to use the autoconnect feature, simply comment these out by adding // at the begining of each line. This will revert the program back to its original ask-for-connection-details behavior.\n\nExample disabled autoconnect:\n\n//cfg.ip =  10.10.39.85 ;\n//cfg.port = 12080;\n\n*/\ncfg.ip =  10.10.39.85 ;\ncfg.port = 12080;\n\n/*\nThis setting, as explained above, disables the  HUB  push notifications feature when set to true.\n*/\ncfg.disablePushNotifications = false; //this leaves push notifications on\n\ncfg.debugToasts = true;\n\ncfg.logallmessages = false; //This will log EVERY WebSockets message that is sent or recieved to the console as a string. This is meant for copying/pasting into GitHub issues and such. It prefaces messages we send with  SENT :   and messages from JMRI with  RECIEVED :", 
            "title": "Example settings.json"
        }, 
        {
            "location": "/userguide/configure-locomotives/", 
            "text": "Setting up your Locomotive Roster\n\n\nSince locoThrottle.js needs quite a bit of information about a locomotive to accurately simulate its physics, we must get additional data about the locomotive that isn't on the JMRI roster. This includes everything from weight, to horsepower, to fuel consumption data.\n\n\nWe also need data on the model, including DCC decoder information (for accurately simulated sounds), and gearing information for the model (so we can run it at the correct speed in scale MPH)\n\n\nIn all, we need 3 key things for any locomotive:\n\n\n\n\n\n\nModel Information:\n This links specific DCC speed values to specific speeds in scale MPH. This is what makes sure the locomotive is going at the correct scale speed.\n\n\n\n\n\n\nDecoder Information:\n This tells the program everything about how your DCC decoder behaves. All decoders have basic support, which includes speed, direction, and lighting, but if you want sound your decoder must be specifically supported.\n\n\n\n\n\n\nPrototype Information:\n This tells the physics simulator everything it needs to know about the prototype locomotive. This data is what's responsible for accurately simulating the behavior of the real thing.\n\n\n\n\n\n\n\n\nTo tell locoThrottle.js the correct combination of those three items for one of your locomotives, we employ \nbundles.json\n. This file contains a series of \"bundles\" that link model and prototype information to a given JMRI roster entry. locoThrottle.js grabs the decoder information straight from the roster. (Handy, huh?)\n\n\nRight now, we don't have a pretty graphical tool for editing \nbundles.json\n. This means you'll have to edit it yourself on your JMRI PC, or whatever you're hosting locoThrottle.js on.\n\n\nBasics\n\n\nbundles.json\n contains a single object, written in JSON format. This object contains a child object for each locomotive.\n\n\n\n\nEditing \nbundles.json\n for Dummies\n\n\nIf you've never edited JSON before, please don't try to set up this file on your own.\n Visit the gitter chat and ask one of the developers to help you. I, \nk4kfh@github\n, will always try my best to help you get this running. I know this can be a daunting task, and I'm working on an automated tool for this, but there are other things I have to get done first.\n\n\n\n\nEditing JSON for Developers\n\n\nThis tutorial is shortened for people who already know/understand JSON syntax.\n\n\n\n\n\n\nOpen \nbundles.json\n from the \n/bundles\n directory of your install folder.\n\n\n\n\n\n\nYou should use a syntax-highlighting capable editor for the best experience with this. This JSON object can become rather lengthy, so an editor that supports collapsibles (such as \nBrackets\n) is highly recommended even for developers.\n\n\n\n\n\n\n\n\nbundles\n object syntax:\n\n\nThe \nbundles\n object is structured in a simple way. It contains a number of subobjects, each named with the roster entry name they represent. For example, I might have a roster entry called \"BN 1776\". In \nbundles\n, that would be represented with:\n\n\nBN 1776\n:{\nsomeString\n:\nsomeValue\n}\n\n\n\n\nYou can have as many of these entries as you want, but make sure you do not have any duplicate entries. There is currently no method in place for having multiple \nbundles\n objects for one locomotive, so be sure you only have one for each.\n\n\n\n\nWhat's inside the entries?\n\n\nBy now, you're probably wondering what exactly is inside of the value for a \nbundles\n object. Below is a structure chart that shows, at a high level, what's in there. You'll have to see the standards pages for some objects to see which objects contain which things, and some may not be documented yet due to rapidly progressing development. Bear with us!\n\n\nEach object is structured like this:\n\n\n\n\n\n\n\"myRosterEntry\"\n - This \nmust\n match the name in JMRI exactly (spaces and all) or it will not work!\n\n\nmodel\n\n\nThis will contain a sub-object that takes in a speed in MPH (from the physics engine) and calculates a speed in speed steps. This varies among locomotives due to gearing, so the best way to find out is to test your locomotive with a scale speedometer and see if you can build an equation that scales it automatically.\n\n\n\n\n\n\nprototype\n\n\nThis will contain an entire prototype object, which is in the process of being standardized now.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSee the comments in the code sample below for explanations.\n\n\nmyRosterEntry\n:{\n    model:{\n        /*\n        This will contain a function that takes in a speed in MPH and converts it to a speed in % for your locomotive. The exact structure of this object is still up in the air a little bit, so it's not documented here until it's finalized.\n        */\n    },\n\n    prototype:{\n        /*\n        This will contain an entire prototype object. You can see what's included in the prototype object standards by visiting Standards \n prototype Objects on the docs.\n        */\n    }\n}", 
            "title": "Configure Locomotives"
        }, 
        {
            "location": "/userguide/configure-locomotives/#setting-up-your-locomotive-roster", 
            "text": "Since locoThrottle.js needs quite a bit of information about a locomotive to accurately simulate its physics, we must get additional data about the locomotive that isn't on the JMRI roster. This includes everything from weight, to horsepower, to fuel consumption data.  We also need data on the model, including DCC decoder information (for accurately simulated sounds), and gearing information for the model (so we can run it at the correct speed in scale MPH)  In all, we need 3 key things for any locomotive:    Model Information:  This links specific DCC speed values to specific speeds in scale MPH. This is what makes sure the locomotive is going at the correct scale speed.    Decoder Information:  This tells the program everything about how your DCC decoder behaves. All decoders have basic support, which includes speed, direction, and lighting, but if you want sound your decoder must be specifically supported.    Prototype Information:  This tells the physics simulator everything it needs to know about the prototype locomotive. This data is what's responsible for accurately simulating the behavior of the real thing.     To tell locoThrottle.js the correct combination of those three items for one of your locomotives, we employ  bundles.json . This file contains a series of \"bundles\" that link model and prototype information to a given JMRI roster entry. locoThrottle.js grabs the decoder information straight from the roster. (Handy, huh?)  Right now, we don't have a pretty graphical tool for editing  bundles.json . This means you'll have to edit it yourself on your JMRI PC, or whatever you're hosting locoThrottle.js on.", 
            "title": "Setting up your Locomotive Roster"
        }, 
        {
            "location": "/userguide/configure-locomotives/#basics", 
            "text": "bundles.json  contains a single object, written in JSON format. This object contains a child object for each locomotive.", 
            "title": "Basics"
        }, 
        {
            "location": "/userguide/configure-locomotives/#editing-bundlesjson-for-dummies", 
            "text": "If you've never edited JSON before, please don't try to set up this file on your own.  Visit the gitter chat and ask one of the developers to help you. I,  k4kfh@github , will always try my best to help you get this running. I know this can be a daunting task, and I'm working on an automated tool for this, but there are other things I have to get done first.", 
            "title": "Editing bundles.json for Dummies"
        }, 
        {
            "location": "/userguide/configure-locomotives/#editing-json-for-developers", 
            "text": "This tutorial is shortened for people who already know/understand JSON syntax.    Open  bundles.json  from the  /bundles  directory of your install folder.    You should use a syntax-highlighting capable editor for the best experience with this. This JSON object can become rather lengthy, so an editor that supports collapsibles (such as  Brackets ) is highly recommended even for developers.     bundles  object syntax:  The  bundles  object is structured in a simple way. It contains a number of subobjects, each named with the roster entry name they represent. For example, I might have a roster entry called \"BN 1776\". In  bundles , that would be represented with:  BN 1776 :{ someString : someValue }  You can have as many of these entries as you want, but make sure you do not have any duplicate entries. There is currently no method in place for having multiple  bundles  objects for one locomotive, so be sure you only have one for each.   What's inside the entries?  By now, you're probably wondering what exactly is inside of the value for a  bundles  object. Below is a structure chart that shows, at a high level, what's in there. You'll have to see the standards pages for some objects to see which objects contain which things, and some may not be documented yet due to rapidly progressing development. Bear with us!  Each object is structured like this:    \"myRosterEntry\"  - This  must  match the name in JMRI exactly (spaces and all) or it will not work!  model  This will contain a sub-object that takes in a speed in MPH (from the physics engine) and calculates a speed in speed steps. This varies among locomotives due to gearing, so the best way to find out is to test your locomotive with a scale speedometer and see if you can build an equation that scales it automatically.    prototype  This will contain an entire prototype object, which is in the process of being standardized now.        See the comments in the code sample below for explanations.  myRosterEntry :{\n    model:{\n        /*\n        This will contain a function that takes in a speed in MPH and converts it to a speed in % for your locomotive. The exact structure of this object is still up in the air a little bit, so it's not documented here until it's finalized.\n        */\n    },\n\n    prototype:{\n        /*\n        This will contain an entire prototype object. You can see what's included in the prototype object standards by visiting Standards   prototype Objects on the docs.\n        */\n    }\n}", 
            "title": "Editing JSON for Developers"
        }, 
        {
            "location": "/devguide/websockets/", 
            "text": "", 
            "title": "WebSockets Interface"
        }, 
        {
            "location": "/devguide/jmri-object/", 
            "text": "", 
            "title": "jmri Object"
        }, 
        {
            "location": "/standards/prototype/", 
            "text": "Prototype Object: Official Standards\n\n\nNote: \nIt is important to note that the prototype object standards are the most rapidly changing standards in the whole program right now. If you are serious about building a prototype object, it would benefit you to read through the comments in the \nbundles.json\n file bundled with ZephyrCab.\n\n\n\n\nIntroduction\n\n\nJust for clarification purposes, please make sure you understand the following:\n\n\n\n\n\n\nThe \nprototype\n object has nothing to do with the physical model or DCC decoder.\n\n\n\n\n\n\nThe \nprototype\n object is stored as a subobject of a train element. For example, \ntrain.all[0].prototype\n would be a prototype object for the first element in the train.\n\n\n\n\n\n\nThe prototype object is different for locomotives and rolling stock.\n\n\n\n\n\n\n\n\nLocomotives\n\n\nLocomotive prototype objects are by far the most complex. They tell everything that \nsim.js\n needs to know about the prototype locomotive, as well as all the information to build a reasonably realistic cab UI.\n\n\nExample Structure:\n\n\nThe prototype object below is for an EMD F7-A. This is a GitHub GIST, so if you know of anything wrong with this standard, please feel free to fix it and create a pull request. I (\nk4kfh\n) do my best to keep it up to date, but sometimes I add something new and forget to update it or don't get time to update it.\n\n\n\n\n\n\n\nRolling Stock\n\n\nThis feature has not been implemented yet. Sorry!", 
            "title": "Prototype Object"
        }, 
        {
            "location": "/standards/prototype/#prototype-object-official-standards", 
            "text": "Note:  It is important to note that the prototype object standards are the most rapidly changing standards in the whole program right now. If you are serious about building a prototype object, it would benefit you to read through the comments in the  bundles.json  file bundled with ZephyrCab.", 
            "title": "Prototype Object: Official Standards"
        }, 
        {
            "location": "/standards/prototype/#introduction", 
            "text": "Just for clarification purposes, please make sure you understand the following:    The  prototype  object has nothing to do with the physical model or DCC decoder.    The  prototype  object is stored as a subobject of a train element. For example,  train.all[0].prototype  would be a prototype object for the first element in the train.    The prototype object is different for locomotives and rolling stock.", 
            "title": "Introduction"
        }, 
        {
            "location": "/standards/prototype/#locomotives", 
            "text": "Locomotive prototype objects are by far the most complex. They tell everything that  sim.js  needs to know about the prototype locomotive, as well as all the information to build a reasonably realistic cab UI.  Example Structure:  The prototype object below is for an EMD F7-A. This is a GitHub GIST, so if you know of anything wrong with this standard, please feel free to fix it and create a pull request. I ( k4kfh ) do my best to keep it up to date, but sometimes I add something new and forget to update it or don't get time to update it.", 
            "title": "Locomotives"
        }, 
        {
            "location": "/standards/prototype/#rolling-stock", 
            "text": "This feature has not been implemented yet. Sorry!", 
            "title": "Rolling Stock"
        }, 
        {
            "location": "/standards/model/", 
            "text": "Model Objects: Official Standards\n\n\nThe model object contains a single function:\n\n\nspeed()\n\n\nThis function takes in a speed in mph (as its only argument) and returns a speed in percent. It must return it as a decimal representation of a percent.\n\n\nFor example, if you knew your model went 25 scale mph at 10% speed, your code sample should behave like this:\n\n\nmph = 25;\nDCCspeed = speed(mph);\n\nconsole.log(DCCspeed) //This should log 0.10 to the console in this example\n\n\n\n\nIt doesn't matter how you get that value, but it should be an equation of some sort. (You cannot use an array and lookup things because decimals will not work right)\n\n\nThis is one of the most open standards the project has. It aims to make it easy for people to add support for any model, from RTR to scratch-built.", 
            "title": "Model Object"
        }, 
        {
            "location": "/standards/model/#model-objects-official-standards", 
            "text": "The model object contains a single function:  speed()  This function takes in a speed in mph (as its only argument) and returns a speed in percent. It must return it as a decimal representation of a percent.  For example, if you knew your model went 25 scale mph at 10% speed, your code sample should behave like this:  mph = 25;\nDCCspeed = speed(mph);\n\nconsole.log(DCCspeed) //This should log 0.10 to the console in this example  It doesn't matter how you get that value, but it should be an equation of some sort. (You cannot use an array and lookup things because decimals will not work right)  This is one of the most open standards the project has. It aims to make it easy for people to add support for any model, from RTR to scratch-built.", 
            "title": "Model Objects: Official Standards"
        }, 
        {
            "location": "/standards/decoder/", 
            "text": "Decoder Constructor: Official Standards\n\n\nDecoder objects are actually constructor functions that, when called, will create an object in the \ntrain\n object capable of controlling the DCC decoder in a decoder-agnostic way. This is not to be confused with \njmri.throttle\n objects, which control the decoder at a lower level.\n\n\nBasics:\n\n\n\n\n\n\nAll decoder objects are located in subobjects of the \ndecoders\n object.\n\n\n\n\n\n\nThe \ndecoders\n object is located in \ndecoders.js\n, which is in \n/cfg\n.\n\n\n\n\n\n\nThe decoders are sorted using the same system JMRI uses: \ndecoderFamily\n and \ndecoderModel\n.\n\n\n\n\n\n\nEach \ndecoderFamily\n is a subobject of \ndecoders\n, and \ndecoderModel\n objects are the subobjects of the families that contain the actual constructor functions. Both subobjects should match the corresponding values from JMRI \nexactly\n.\n\n\n\n\n\n\nLocation\n\n\nThe main \ndecoders\n object contains all the decoder constructors. This object is located in \n/cfg/decoders.js\n. It is already added by default to \nindex.html\n, there is no need to add a \nscript\n tag or anything of that nature. It is designed to \"just work\" with minimal effort required to add decoders.\n\n\nThis file can be redownloaded in the event of an accident from the \nZephyrCab GitHub.\n This should rarely happen, especially when used with a proper editor. Something that supports collapsible objects (such as \nBrackets\n) should work quite well for this.\n\n\nObject Structure\n\n\nThe structure of \ndecoders\n is hierarchical. It works like so:\n\n\ndecoders ---\n decoderFamily ---\n decoderModel\n\n\n\n\ndecoderFamily\n and \ndecoderModel\n are both strings. For the program's automatic decoder selector to work correctly, these must \nexactly\n match the strings stored in the JMRI roster. They \nare\n case sensitive!\n\n\nConstructor Contents\n\n\nSo now that you know where to find the constructor for a specific decoder, you're probably wondering what these complex constructors have inside them.\n\n\nEvery constructor should have the same functions. Even if your decoder does not support a certain feature, you should put the functions in the constructor (just make them dummy functions). This modular approach means we don't have to deal with variables being undefined; we can just call a function and know that (if standards are being followed) then the decoder will cooperate.\n\n\nThe bullet list hierarchy below shows the standard contents of a decoder constructor object. Keep in mind that when writing these functions, you will need to make use of JavaScript's \nthis\n variable to make the structure apply to the object being created.\n\n\n\n\nStructure\n\n\n\n\nf\n\n\nheadlight\n\n\nset()\n\n\nstate\n\n\n\n\n\n\nhorn\n\n\nset()\n\n\nstate\n\n\n\n\n\n\nbell\n\n\nset()\n\n\nstate\n\n\n\n\n\n\ncompressor\n\n\nset()\n\n\nstate\n\n\n\n\n\n\nairdump\n\n\nset()\n\n\nstate\n\n\n\n\n\n\ndynbrakes\n\n\nset()\n\n\nstate\n\n\n\n\n\n\nengine\n\n\nset()\n\n\nstate\n\n\n\n\n\n\nnotch\n\n\nup()\n\n\ndown()\n\n\nstate\n\n\n\n\n\n\n\n\n\n\nspeed\n\n\nset()\n\n\nstate\n\n\n\n\n\n\n\n\n\n\nDo not forget that \nall decoder objects must contain every standard function, and should not contain any non-standard functions.\n If the decoder object structure becomes nonstandardized, the useful modularity of ZephyrCab is lost.\n\n\nThe reason it is built like this is to allow support for everything from generic DCC decoders to the best sound decoders in the world. The \ndecoders\n object provides a \"layer\" that makes the rest of ZephyrCab decoder agnostic, so it is important that standards are followed.\n\n\n\n\nFunction Logic\n\n\nObviously since we're talking about constructor functions here, they're not just variables, they perform tasks. Your decoder constructor function will be called by the train builder UI when a user adds a locomotive with the corresponding decoder to their train.\n\n\nArguments\n\n\nALL decoder constructors must accept the following arguments:\n\n\n\n\n\n\naddress\n\n\n\n\n\n\ntrainPosition\n\n\n\n\n\n\nNo function should accept any additional arguments, as this will only cause problems.\n\n\nTasks\n\n\nSo what exactly should this function do?\n\n\nHere is a summary of the tasks a decoder constructor must perform.\n\n\n\n\n\n\n\n\nCreate all the necessary objects for DCC functions\n\n\n\n\n\n\nCall \njmri.throttle\n to create a throttle object for the new train element. Please make sure to use \njmri.throttleName.generate()\n as your throttle name argument. This makes sure every throttle has a unique name; a JMRI requirement. (see the example below for an implementation)\n\n\n\n\n\n\n\n\nExample Object\n\n\nAn example \ndecoders\n object is shown below, with annotations.\n\n\nThis example is a GitHub Gist, so feel free to contribute if you see fit. You may also use any of this code in your own \ndecoder\n objects; it is totally open for anyone to use.", 
            "title": "Decoder Object"
        }, 
        {
            "location": "/standards/decoder/#decoder-constructor-official-standards", 
            "text": "Decoder objects are actually constructor functions that, when called, will create an object in the  train  object capable of controlling the DCC decoder in a decoder-agnostic way. This is not to be confused with  jmri.throttle  objects, which control the decoder at a lower level.", 
            "title": "Decoder Constructor: Official Standards"
        }, 
        {
            "location": "/standards/decoder/#basics", 
            "text": "All decoder objects are located in subobjects of the  decoders  object.    The  decoders  object is located in  decoders.js , which is in  /cfg .    The decoders are sorted using the same system JMRI uses:  decoderFamily  and  decoderModel .    Each  decoderFamily  is a subobject of  decoders , and  decoderModel  objects are the subobjects of the families that contain the actual constructor functions. Both subobjects should match the corresponding values from JMRI  exactly .", 
            "title": "Basics:"
        }, 
        {
            "location": "/standards/decoder/#location", 
            "text": "The main  decoders  object contains all the decoder constructors. This object is located in  /cfg/decoders.js . It is already added by default to  index.html , there is no need to add a  script  tag or anything of that nature. It is designed to \"just work\" with minimal effort required to add decoders.  This file can be redownloaded in the event of an accident from the  ZephyrCab GitHub.  This should rarely happen, especially when used with a proper editor. Something that supports collapsible objects (such as  Brackets ) should work quite well for this.", 
            "title": "Location"
        }, 
        {
            "location": "/standards/decoder/#object-structure", 
            "text": "The structure of  decoders  is hierarchical. It works like so:  decoders ---  decoderFamily ---  decoderModel  decoderFamily  and  decoderModel  are both strings. For the program's automatic decoder selector to work correctly, these must  exactly  match the strings stored in the JMRI roster. They  are  case sensitive!", 
            "title": "Object Structure"
        }, 
        {
            "location": "/standards/decoder/#constructor-contents", 
            "text": "So now that you know where to find the constructor for a specific decoder, you're probably wondering what these complex constructors have inside them.  Every constructor should have the same functions. Even if your decoder does not support a certain feature, you should put the functions in the constructor (just make them dummy functions). This modular approach means we don't have to deal with variables being undefined; we can just call a function and know that (if standards are being followed) then the decoder will cooperate.  The bullet list hierarchy below shows the standard contents of a decoder constructor object. Keep in mind that when writing these functions, you will need to make use of JavaScript's  this  variable to make the structure apply to the object being created.   Structure   f  headlight  set()  state    horn  set()  state    bell  set()  state    compressor  set()  state    airdump  set()  state    dynbrakes  set()  state    engine  set()  state    notch  up()  down()  state      speed  set()  state      Do not forget that  all decoder objects must contain every standard function, and should not contain any non-standard functions.  If the decoder object structure becomes nonstandardized, the useful modularity of ZephyrCab is lost.  The reason it is built like this is to allow support for everything from generic DCC decoders to the best sound decoders in the world. The  decoders  object provides a \"layer\" that makes the rest of ZephyrCab decoder agnostic, so it is important that standards are followed.", 
            "title": "Constructor Contents"
        }, 
        {
            "location": "/standards/decoder/#function-logic", 
            "text": "Obviously since we're talking about constructor functions here, they're not just variables, they perform tasks. Your decoder constructor function will be called by the train builder UI when a user adds a locomotive with the corresponding decoder to their train.", 
            "title": "Function Logic"
        }, 
        {
            "location": "/standards/decoder/#arguments", 
            "text": "ALL decoder constructors must accept the following arguments:    address    trainPosition    No function should accept any additional arguments, as this will only cause problems.", 
            "title": "Arguments"
        }, 
        {
            "location": "/standards/decoder/#tasks", 
            "text": "So what exactly should this function do?  Here is a summary of the tasks a decoder constructor must perform.     Create all the necessary objects for DCC functions    Call  jmri.throttle  to create a throttle object for the new train element. Please make sure to use  jmri.throttleName.generate()  as your throttle name argument. This makes sure every throttle has a unique name; a JMRI requirement. (see the example below for an implementation)", 
            "title": "Tasks"
        }, 
        {
            "location": "/standards/decoder/#example-object", 
            "text": "An example  decoders  object is shown below, with annotations.  This example is a GitHub Gist, so feel free to contribute if you see fit. You may also use any of this code in your own  decoder  objects; it is totally open for anyone to use.", 
            "title": "Example Object"
        }
    ]
}